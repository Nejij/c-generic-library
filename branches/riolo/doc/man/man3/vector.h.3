.TH "/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/vector.h" 3 "Mon Aug 15 2011" ""c generic library"" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/vector.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'gen/gen_macros.h'\fP
.br
\fC#include 'gen/data_types.h'\fP
.br
\fC#include 'gen/function_macros.h'\fP
.br
\fC#include 'gen/function_signatures.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBVECTOR_ITER_DEFINED\fP"
.br
.ti -1c
.RI "#define \fBVECTOR_DEFINED\fP"
.br
.ti -1c
.RI "#define \fBFUNC\fP(X, Y)   ((X)->API.Y(X));"
.br
.ti -1c
.RI "#define \fBconvert_Vector\fP(A, B, C, D)   push_back_Vector((A),(B),(C),(D))"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_array_iter\fP \fBVectorIter\fP"
.br
.ti -1c
.RI "typedef struct \fB_array_struct\fP \fBVector\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int8_t \fBconstruct_Vector\fP (\fBVector\fP *obj, size_t datasize, int flag)"
.br
.ti -1c
.RI "int8_t \fBconstruct_func_Vector\fP (\fBVector\fP *obj, size_t datasize, int flag, void *(*alloc)(size_t), void(*dealloc)(void *), int32_t(*cmp)(const void *, const void *, size_t), void(*print)(const void *), void *(*copy)(void *, const void *, size_t))"
.br
.RI "\fIassigns all the * function pointers in one function call \fP"
.ti -1c
.RI "int8_t \fBdestruct_Vector\fP (\fBVector\fP *obj)"
.br
.RI "\fIRemoves all the allocated memory for * the object. \fP"
.ti -1c
.RI "int8_t \fBclear_Vector\fP (\fBVector\fP *obj)"
.br
.RI "\fIremoves all the data from the object \fP"
.ti -1c
.RI "\fBVector\fP * \fBduplicate_Vector\fP (\fBVector\fP *obj)"
.br
.RI "\fIduplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. \fP"
.ti -1c
.RI "int8_t \fBprint_Vector\fP (\fBVector\fP *obj)"
.br
.RI "\fIprints out the data inside the object \fP"
.ti -1c
.RI "int8_t \fBempty_Vector\fP (\fBVector\fP *obj)"
.br
.ti -1c
.RI "size_t \fBsize_Vector\fP (\fBVector\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBdump_Vector\fP (\fBVector\fP *obj)"
.br
.RI "\fIdumps out the internal structure of the object \fP"
.ti -1c
.RI "size_t \fBsize_of_Vector\fP (\fBVector\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBset_compare_Vector\fP (\fBVector\fP *obj, int32_t(*cmp)(const void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBset_print_Vector\fP (\fBVector\fP *obj, void(*print)(const void *))"
.br
.ti -1c
.RI "int8_t \fBset_alloc_Vector\fP (\fBVector\fP *obj, void *(*alloc)(size_t))"
.br
.ti -1c
.RI "int8_t \fBset_dealloc_Vector\fP (\fBVector\fP *obj, void(*dealloc)(void *))"
.br
.ti -1c
.RI "int8_t \fBset_copy_Vector\fP (\fBVector\fP *obj, void *(*copy)(void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBinsert_at_Vector\fP (\fBVector\fP *vec, void *obj, uint32_t loc)"
.br
.RI "\fIinserts into the array at a specific index the object This is the equivalent of the vec[index] = obj operation \fP"
.ti -1c
.RI "int8_t \fBinsert_Vector\fP (\fBVector\fP *vec, void *obj, size_t objsize, int flag)"
.br
.RI "\fIinserts the object into the array in sorted order \fP"
.ti -1c
.RI "int8_t \fBpush_back_Vector\fP (\fBVector\fP *vec, void *obj, size_t objsize, int flag)"
.br
.ti -1c
.RI "int8_t \fBpush_front_Vector\fP (\fBVector\fP *vec, void *obj, size_t objsize, int flag)"
.br
.ti -1c
.RI "int8_t \fBpop_back_Vector\fP (\fBVector\fP *vec)"
.br
.ti -1c
.RI "int8_t \fBpop_front_Vector\fP (\fBVector\fP *vec)"
.br
.ti -1c
.RI "void * \fBfront_Vector\fP (\fBVector\fP *vec)"
.br
.ti -1c
.RI "void * \fBback_Vector\fP (\fBVector\fP *vec)"
.br
.ti -1c
.RI "void * \fBreturn_at_Vector\fP (\fBVector\fP *vec, uint32_t loc)"
.br
.RI "\fIreturns the object from the vector at the given point \fP"
.ti -1c
.RI "int8_t \fBresize_Vector\fP (\fBVector\fP *vec, size_t size)"
.br
.RI "\fIresizes the array that is inside of the vector and copies the first n objects over to the new array \fP"
.ti -1c
.RI "int8_t \fBprev_VectorIter\fP (\fBVectorIter\fP *iter)"
.br
.RI "\fImoves the iterator to the prev element in the * obj \fP"
.ti -1c
.RI "int8_t \fBnext_VectorIter\fP (\fBVectorIter\fP *iter)"
.br
.RI "\fImoves the iterator to the next element in the * obj \fP"
.ti -1c
.RI "int8_t \fBassign_VectorIter\fP (\fBVectorIter\fP *iter, \fBVector\fP *obj)"
.br
.RI "\fIassign statically created iterator to the obj \fP"
.ti -1c
.RI "void \fBdestroy_VectorIter\fP (\fBVectorIter\fP *iter)"
.br
.ti -1c
.RI "int8_t \fBhead_VectorIter\fP (\fBVectorIter\fP *iter)"
.br
.RI "\fImoves the iterator to the head of the obj * it has been assigned to \fP"
.ti -1c
.RI "int8_t \fBtail_VectorIter\fP (\fBVectorIter\fP *iter)"
.br
.RI "\fImoves the iterator to the tail of the * obj it has been assigned to \fP"
.ti -1c
.RI "\fBVectorIter\fP * \fBcreate_VectorIter\fP (\fBVector\fP *obj)"
.br
.RI "\fIcreates and iterator and assigns it to the obj \fP"
.ti -1c
.RI "void * \fBretrieve_VectorIter\fP (\fBVectorIter\fP *iter)"
.br
.RI "\fIreturns a void poitner to the object that * the iterator points to \fP"
.ti -1c
.RI "int8_t \fBcopy_VectorIter\fP (\fBVectorIter\fP *src, \fBVectorIter\fP *dst)"
.br
.ti -1c
.RI "int8_t \fBswap_VectorIter\fP (\fBVectorIter\fP *iter1, \fBVectorIter\fP *iter2)"
.br
.RI "\fIswaps the position of iter1 and iter2 * \fP"
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define convert_Vector(A, B, C, D)   push_back_Vector((A),(B),(C),(D))"
.PP
Definition at line 32 of file vector.h.
.SS "#define FUNC(X, Y)   ((X)->API.Y(X));"
.PP
Definition at line 28 of file vector.h.
.SS "#define VECTOR_DEFINED"
.PP
Definition at line 24 of file vector.h.
.SS "#define VECTOR_ITER_DEFINED"
.PP
Definition at line 18 of file vector.h.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_array_struct\fP \fBVector\fP"
.PP
Definition at line 25 of file vector.h.
.SS "typedef struct \fB_array_iter\fP \fBVectorIter\fP"
.PP
Definition at line 19 of file vector.h.
.SH "Function Documentation"
.PP 
.SS "int8_t assign_VectorIter (\fBVectorIter\fP *iter, \fBVector\fP *obj)"
.PP
assign statically created iterator to the obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to assign to the obj * 
.br
\fIobj\fP the obj to point the iterator to * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "void* back_Vector (\fBVector\fP *vec)"
.SS "int8_t clear_Vector (\fBVector\fP *obj)"
.PP
removes all the data from the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to clear * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * 
.RE
.PP

.SS "int8_t construct_func_Vector (\fBVector\fP *obj, size_tdatasize, intflag, void *(*)(size_t)alloc, void(*)(void *)dealloc, int32_t(*)(const void *, const void *, size_t)cmp, void(*)(const void *)print, void *(*)(void *, const void *, size_t)copy)"
.PP
assigns all the * function pointers in one function call * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.br
\fIalloc\fP the allocation functor * 
.br
\fIdealloc\fP the deallocation functor * 
.br
\fIcmp\fP the comparison functor * 
.br
\fIprint\fP the print functor * 
.br
\fIcopy\fP the copy functor * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP

.SS "int8_t construct_Vector (\fBVector\fP *obj, size_tdatasize, intflag)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP
\fBWarning:\fP
.RS 4
if you are using a local variable * clear out the memory before calling this * function using memset or bzero 
.RE
.PP

.SS "int8_t copy_VectorIter (\fBVectorIter\fP *src, \fBVectorIter\fP *dst)"* 
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP the source iterator * 
.br
\fIdst\fP the destination iterator * 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success, non-zero on error 
.RE
.PP

.SS "\fBVectorIter\fP* create_VectorIter (\fBVector\fP *obj)"
.PP
creates and iterator and assigns it to the obj * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to create iterator for * 
.RE
.PP
\fBReturns:\fP
.RS 4
returns an iterator to the obj on success * or NULL on error * 
.RE
.PP

.SS "void destroy_VectorIter (\fBVectorIter\fP *iter)"* 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to destroy * 
.RE
.PP
\fBWarning:\fP
.RS 4
only use this in conjunction with create 
.RE
.PP

.SS "int8_t destruct_Vector (\fBVector\fP *obj)"
.PP
Removes all the allocated memory for * the object. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to deinitialize * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on succss, non-zero on failure * 
.RE
.PP

.SS "int8_t dump_Vector (\fBVector\fP *obj)"
.PP
dumps out the internal structure of the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to dump the internal structure of * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success,non-zero on error * 
.RE
.PP

.SS "\fBVector\fP* duplicate_Vector (\fBVector\fP *obj)"
.PP
duplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to duplicate * 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of the object or NULL on error * 
.RE
.PP

.SS "int8_t empty_Vector (\fBVector\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to check for emptiness * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on empty, non-zero otherwise 
.RE
.PP

.SS "void* front_Vector (\fBVector\fP *vec)"
.SS "int8_t head_VectorIter (\fBVectorIter\fP *iter)"
.PP
moves the iterator to the head of the obj * it has been assigned to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to move to the head * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t insert_at_Vector (\fBVector\fP *vec, void *obj, uint32_tloc)"
.PP
inserts into the array at a specific index the object This is the equivalent of the vec[index] = obj operation \fBParameters:\fP
.RS 4
\fIvec\fP the vector to insert the object into 
.br
\fIobj\fP the object to insert into the array 
.br
\fIloc\fP the location in the array to put the item 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t insert_Vector (\fBVector\fP *vec, void *obj, size_tobjsize, intflag)"
.PP
inserts the object into the array in sorted order \fBParameters:\fP
.RS 4
\fIvec\fP the vector to insert the object into 
.br
\fIobj\fP the object to insert into the array 
.br
\fIobjsize\fP the size of the object being inserted into the vector 
.br
\fIflag\fP the flag specifying whether it is static or dynamic data 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t next_VectorIter (\fBVectorIter\fP *iter)"
.PP
moves the iterator to the next element in the * obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iter to move to the next element * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t pop_back_Vector (\fBVector\fP *vec)"
.SS "int8_t pop_front_Vector (\fBVector\fP *vec)"
.SS "int8_t prev_VectorIter (\fBVectorIter\fP *iter)"
.PP
moves the iterator to the prev element in the * obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iter to move to the prev element * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t print_Vector (\fBVector\fP *obj)"
.PP
prints out the data inside the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to print * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t push_back_Vector (\fBVector\fP *vec, void *obj, size_tobjsize, intflag)"
.SS "int8_t push_front_Vector (\fBVector\fP *vec, void *obj, size_tobjsize, intflag)"
.SS "int8_t resize_Vector (\fBVector\fP *vec, size_tsize)"
.PP
resizes the array that is inside of the vector and copies the first n objects over to the new array \fBParameters:\fP
.RS 4
\fIvec\fP the vector to resize 
.br
\fIsize\fP the size to resize the vector to 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero otherwise 
.RE
.PP

.SS "void* retrieve_VectorIter (\fBVectorIter\fP *iter)"
.PP
returns a void poitner to the object that * the iterator points to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to retrieve the object from * 
.RE
.PP
\fBReturns:\fP
.RS 4
object on success, NULL on error * 
.RE
.PP

.SS "void * return_at_Vector (\fBVector\fP *vec, uint32_tloc)"
.PP
returns the object from the vector at the given point \fBParameters:\fP
.RS 4
\fIvec\fP the vector to return the object into 
.br
\fIloc\fP the loc in the array to return the object from 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to the object on success, NULL on error 
.RE
.PP

.SS "int8_t set_alloc_Vector (\fBVector\fP *obj, void *(*)(size_t)alloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the alloc funtion for * 
.br
\fIalloc\fP the function pointer to the alloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_compare_Vector (\fBVector\fP *obj, int32_t(*)(const void *, const void *, size_t)cmp)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the compare function of * 
.br
\fIcmp\fP the function pointer to the comparison function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_copy_Vector (\fBVector\fP *obj, void *(*)(void *, const void *, size_t)copy)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to set the copy function for * 
.br
\fIcopy\fP the function pointer to the copy function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_dealloc_Vector (\fBVector\fP *obj, void(*)(void *)dealloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP the obj to set the dealloc function for * 
.br
\fIdealloc\fP the function pointer to the dealloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_print_Vector (\fBVector\fP *obj, void(*)(const void *)print)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the print function of * 
.br
\fIprint\fP the function pointer to the print function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "size_t size_of_Vector (\fBVector\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of the object or 0 on error/empty 
.RE
.PP

.SS "size_t size_Vector (\fBVector\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of object or zero on failure 
.RE
.PP

.SS "int8_t swap_VectorIter (\fBVectorIter\fP *iter1, \fBVectorIter\fP *iter2)"
.PP
swaps the position of iter1 and iter2 * * 
.PP
\fBParameters:\fP
.RS 4
\fIiter1\fP the first iterator * 
.br
\fIiter2\fP the second iterator * 
.RE
.PP
\fBWarning:\fP
.RS 4
iterators must be pointing to same parent * object or the swap will fail * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t tail_VectorIter (\fBVectorIter\fP *iter)"
.PP
moves the iterator to the tail of the * obj it has been assigned to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to move to the tail * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 'c generic library' from the source code.
