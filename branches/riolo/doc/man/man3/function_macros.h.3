.TH "/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/gen/function_macros.h" 3 "Mon Aug 15 2011" ""c generic library"" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/gen/function_macros.h \- 
.PP
function macros that expand to the actual functions  

.SH SYNOPSIS
.br
.PP
\fC#include 'access_macros.h'\fP
.br

.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBconstruct\fP(TYPE, STRUCT, OBJSIZE, FLAG)   construct_##TYPE((STRUCT),OBJSIZE,FLAG)"
.br
.RI "\fIexpands to the correct structure for the construct function \fP"
.ti -1c
.RI "#define \fBconstruct_func\fP(TYPE, STRUCT, OBJSIZE, FLAG, ALLOC, DEALLOC, CMP, PRINT, COPY)   construct_func_##TYPE(STRUCT,OBJSIZE,FLAG,ALLOC,DEALLOC,CMP,PRINT,COPY)"
.br
.RI "\fIexpands to the correct format for the construct_func function \fP"
.ti -1c
.RI "#define \fBdestruct\fP(TYPE, STRUCT)   destruct_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the destruct function \fP"
.ti -1c
.RI "#define \fBclear\fP(TYPE, STRUCT)   clear_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the clear function \fP"
.ti -1c
.RI "#define \fBpop\fP(TYPE, STRUCT)   pop_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the pop function \fP"
.ti -1c
.RI "#define \fBpop_back\fP(TYPE, STRUCT)   pop_back_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the pop_back function \fP"
.ti -1c
.RI "#define \fBpop_front\fP(TYPE, STRUCT)   pop_front_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the pop_front function \fP"
.ti -1c
.RI "#define \fBfront\fP(TYPE, STRUCT)   front_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the front function \fP"
.ti -1c
.RI "#define \fBduplicate\fP(TYPE, STRUCT)   duplicate_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the duplicate function \fP"
.ti -1c
.RI "#define \fBtop\fP(TYPE, STRUCT)   top_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the top function \fP"
.ti -1c
.RI "#define \fBback\fP(TYPE, STRUCT)   back_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the back function \fP"
.ti -1c
.RI "#define \fBpush\fP(TYPE, STRUCT, OBJ, FLAG)   push_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.br
.RI "\fIexpands to the correct format for the push function. The OBJ macro parameter should be a pointer to the object and not the object itself. \fP"
.ti -1c
.RI "#define \fBpush_back\fP(TYPE, STRUCT, OBJ, FLAG)   push_back_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.br
.RI "\fIexpands to the correct format for the push_back function The OBJ macro parameter should be a pointer to the object and not the object itself. \fP"
.ti -1c
.RI "#define \fBpush_front\fP(TYPE, STRUCT, OBJ, FLAG)   push_front_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.br
.RI "\fIexpands to the correct format for the push_front function The OBJ macro parameter should be a pointer to the object and not the object itself. \fP"
.ti -1c
.RI "#define \fBdelete\fP(TYPE, STRUCT, OBJ)   delete_##TYPE((STRUCT),(OBJ),sizeof *(OBJ))"
.br
.RI "\fIexpands to the correct format for the delete function The OBJ macro parameter should be a pointer to the object and not the object itself. \fP"
.ti -1c
.RI "#define \fBinsert\fP(TYPE, STRUCT, OBJ, FLAG)   insert_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.br
.RI "\fIexpands to the correct format for the insert function The OBJ macro parameter should be a pointer to the object and not the object itself. \fP"
.ti -1c
.RI "#define \fBconvert\fP(TYPE, STRUCT, OBJ, SIZE, FLAG)   convert_##TYPE((STRUCT),(OBJ),(SIZE),(FLAG))"
.br
.RI "\fIexpands to the correct format for the convert function The OBJ macro parameter should be a pointer to the object and not the object itself. \fP"
.ti -1c
.RI "#define \fBfind\fP(TYPE, STRUCT, OBJ)   find_##TYPE((STRUCT),(OBJ),sizeof *(OBJ))"
.br
.RI "\fIexpands to the correct format for the find function The OBJ macro parameter should be a pointer to the object and not the object itself. \fP"
.ti -1c
.RI "#define \fBresize\fP(TYPE, STRUCT, SIZE)   resize_##TYPE((STRUCT),(SIZE))"
.br
.RI "\fIexpands to the correct format for the resize function \fP"
.ti -1c
.RI "#define \fBsort\fP(TYPE, STRUCT)   sort_##TYPE((STRUCT),O(STRUCT))"
.br
.RI "\fIexpands to the correct format for the sort function \fP"
.ti -1c
.RI "#define \fBrsort\fP(TYPE, STRUCT)   rsort_##TYPE((STRUCT),O(STRUCT))"
.br
.RI "\fIexpands to the correct format for the reverse sort function \fP"
.ti -1c
.RI "#define \fBset_free_objects\fP(TYPE, STRUCT, OBJ)   set_free_objects_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set free objects function \fP"
.ti -1c
.RI "#define \fBdump\fP(TYPE, STRUCT)   dump_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the dump function \fP"
.ti -1c
.RI "#define \fBprint_all\fP(TYPE, STRUCT)   print_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the print all function \fP"
.ti -1c
.RI "#define \fBset_object_size\fP(TYPE, STRUCT, OBJ)   set_object_size_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set object size function \fP"
.ti -1c
.RI "#define \fBsize_of\fP(TYPE, STRUCT)   size_of_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the size of function \fP"
.ti -1c
.RI "#define \fBsize\fP(TYPE, STRUCT)   size_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the size function \fP"
.ti -1c
.RI "#define \fBempty\fP(TYPE, STRUCT)   empty_##TYPE((STRUCT))"
.br
.RI "\fIexpands to the correct format for the empty function \fP"
.ti -1c
.RI "#define \fBset_compare\fP(TYPE, STRUCT, OBJ)   set_compare_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set compare function \fP"
.ti -1c
.RI "#define \fBset_rcompare\fP(TYPE, STRUCT, OBJ)   set_rcompare_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set rcompare function \fP"
.ti -1c
.RI "#define \fBset_print\fP(TYPE, STRUCT, OBJ)   set_print_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set print function \fP"
.ti -1c
.RI "#define \fBset_copy\fP(TYPE, STRUCT, OBJ)   set_copy_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set copy function \fP"
.ti -1c
.RI "#define \fBset_alloc\fP(TYPE, STRUCT, OBJ)   set_alloc_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set alloc function \fP"
.ti -1c
.RI "#define \fBset_dealloc\fP(TYPE, STRUCT, OBJ)   set_dealloc_##TYPE((STRUCT),(OBJ))"
.br
.RI "\fIexpands to the correct format for the set dealloc function \fP"
.ti -1c
.RI "#define \fBITER\fP(X)   X##Iter"
.br
.ti -1c
.RI "#define \fBtail\fP(TYPE, ITER)   tail_##TYPE((ITER))"
.br
.RI "\fIexpands to the correct format for the tail iterator function \fP"
.ti -1c
.RI "#define \fBhead\fP(TYPE, ITER)   head_##TYPE((ITER))"
.br
.RI "\fIexpands to the correct format for the head iterator function \fP"
.ti -1c
.RI "#define \fBretrieve\fP(TYPE, ITER)   retrieve_##TYPE((ITER))"
.br
.RI "\fIexpands to the correct format for the retrieve iterator function \fP"
.ti -1c
.RI "#define \fBnext\fP(TYPE, ITER)   next_##TYPE((ITER))"
.br
.RI "\fIexpands to the correct format for the next iterator function \fP"
.ti -1c
.RI "#define \fBprev\fP(TYPE, ITER)   prev_##TYPE((ITER))"
.br
.RI "\fIexpands to the correct format for the prev iterator function \fP"
.ti -1c
.RI "#define \fBextract\fP(TYPE, ITER)   extract_##TYPE((ITER))"
.br
.RI "\fIexpands to the correct format for the extract iterator function \fP"
.ti -1c
.RI "#define \fBassign\fP(TYPE, ITER, PARENT)   assign_##TYPE((ITER),(PARENT))"
.br
.RI "\fIexpands to the correct format for the assign iterator function \fP"
.ti -1c
.RI "#define \fBdestroy\fP(TYPE, ITER)   destroy_##TYPE((ITER))"
.br
.RI "\fIexpands to the correct format for the destroy iterator function \fP"
.ti -1c
.RI "#define \fBcreate\fP(TYPE, PARENT)   create_##TYPE((PARENT))"
.br
.RI "\fIexpands to the correct format for the create iterator function \fP"
.ti -1c
.RI "#define \fBCHECK_FLAG\fP(X, Y)   (((X) & (Y)) == (Y))"
.br
.RI "\fImacro to check if a flag is set in a integer \fP"
.in -1c
.SH "Detailed Description"
.PP 
function macros that expand to the actual functions 

Copyright 2006, Micah Villmow, All Rights Reserved
.PP
\fBAuthor:\fP
.RS 4
Micah Villmow 
.RE
.PP

.PP
Definition in file \fBfunction_macros.h\fP.
.SH "Define Documentation"
.PP 
.SS "#define assign(TYPE, ITER, PARENT)   assign_##TYPE((ITER),(PARENT))"
.PP
expands to the correct format for the assign iterator function 
.PP
Definition at line 246 of file function_macros.h.
.SS "#define back(TYPE, STRUCT)   back_##TYPE((STRUCT))"
.PP
expands to the correct format for the back function 
.PP
Definition at line 71 of file function_macros.h.
.SS "#define CHECK_FLAG(X, Y)   (((X) & (Y)) == (Y))"
.PP
macro to check if a flag is set in a integer 
.PP
Definition at line 261 of file function_macros.h.
.SS "#define clear(TYPE, STRUCT)   clear_##TYPE((STRUCT))"
.PP
expands to the correct format for the clear function 
.PP
Definition at line 36 of file function_macros.h.
.SS "#define construct(TYPE, STRUCT, OBJSIZE, FLAG)   construct_##TYPE((STRUCT),OBJSIZE,FLAG)"
.PP
expands to the correct structure for the construct function 
.PP
Definition at line 21 of file function_macros.h.
.SS "#define construct_func(TYPE, STRUCT, OBJSIZE, FLAG, ALLOC, DEALLOC, CMP, PRINT, COPY)   construct_func_##TYPE(STRUCT,OBJSIZE,FLAG,ALLOC,DEALLOC,CMP,PRINT,COPY)"
.PP
expands to the correct format for the construct_func function 
.PP
Definition at line 26 of file function_macros.h.
.SS "#define convert(TYPE, STRUCT, OBJ, SIZE, FLAG)   convert_##TYPE((STRUCT),(OBJ),(SIZE),(FLAG))"
.PP
expands to the correct format for the convert function The OBJ macro parameter should be a pointer to the object and not the object itself. 
.PP
Definition at line 113 of file function_macros.h.
.SS "#define create(TYPE, PARENT)   create_##TYPE((PARENT))"
.PP
expands to the correct format for the create iterator function 
.PP
Definition at line 256 of file function_macros.h.
.SS "#define delete(TYPE, STRUCT, OBJ)   delete_##TYPE((STRUCT),(OBJ),sizeof *(OBJ))"
.PP
expands to the correct format for the delete function The OBJ macro parameter should be a pointer to the object and not the object itself. 
.PP
Definition at line 99 of file function_macros.h.
.SS "#define destroy(TYPE, ITER)   destroy_##TYPE((ITER))"
.PP
expands to the correct format for the destroy iterator function 
.PP
Definition at line 251 of file function_macros.h.
.SS "#define destruct(TYPE, STRUCT)   destruct_##TYPE((STRUCT))"
.PP
expands to the correct format for the destruct function 
.PP
Definition at line 31 of file function_macros.h.
.SS "#define dump(TYPE, STRUCT)   dump_##TYPE((STRUCT))"
.PP
expands to the correct format for the dump function 
.PP
Definition at line 145 of file function_macros.h.
.SS "#define duplicate(TYPE, STRUCT)   duplicate_##TYPE((STRUCT))"
.PP
expands to the correct format for the duplicate function 
.PP
Definition at line 61 of file function_macros.h.
.SS "#define empty(TYPE, STRUCT)   empty_##TYPE((STRUCT))"
.PP
expands to the correct format for the empty function 
.PP
Definition at line 174 of file function_macros.h.
.SS "#define extract(TYPE, ITER)   extract_##TYPE((ITER))"
.PP
expands to the correct format for the extract iterator function 
.PP
Definition at line 241 of file function_macros.h.
.SS "#define find(TYPE, STRUCT, OBJ)   find_##TYPE((STRUCT),(OBJ),sizeof *(OBJ))"
.PP
expands to the correct format for the find function The OBJ macro parameter should be a pointer to the object and not the object itself. 
.PP
Definition at line 120 of file function_macros.h.
.SS "#define front(TYPE, STRUCT)   front_##TYPE((STRUCT))"
.PP
expands to the correct format for the front function 
.PP
Definition at line 56 of file function_macros.h.
.SS "#define head(TYPE, ITER)   head_##TYPE((ITER))"
.PP
expands to the correct format for the head iterator function 
.PP
Definition at line 221 of file function_macros.h.
.SS "#define insert(TYPE, STRUCT, OBJ, FLAG)   insert_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.PP
expands to the correct format for the insert function The OBJ macro parameter should be a pointer to the object and not the object itself. 
.PP
Definition at line 106 of file function_macros.h.
.SS "#define ITER(X)   X##Iter"
.PP
Definition at line 212 of file function_macros.h.
.SS "#define next(TYPE, ITER)   next_##TYPE((ITER))"
.PP
expands to the correct format for the next iterator function 
.PP
Definition at line 231 of file function_macros.h.
.SS "#define pop(TYPE, STRUCT)   pop_##TYPE((STRUCT))"
.PP
expands to the correct format for the pop function 
.PP
Definition at line 41 of file function_macros.h.
.SS "#define pop_back(TYPE, STRUCT)   pop_back_##TYPE((STRUCT))"
.PP
expands to the correct format for the pop_back function 
.PP
Definition at line 46 of file function_macros.h.
.SS "#define pop_front(TYPE, STRUCT)   pop_front_##TYPE((STRUCT))"
.PP
expands to the correct format for the pop_front function 
.PP
Definition at line 51 of file function_macros.h.
.SS "#define prev(TYPE, ITER)   prev_##TYPE((ITER))"
.PP
expands to the correct format for the prev iterator function 
.PP
Definition at line 236 of file function_macros.h.
.SS "#define print_all(TYPE, STRUCT)   print_##TYPE((STRUCT))"
.PP
expands to the correct format for the print all function 
.PP
Definition at line 150 of file function_macros.h.
.SS "#define push(TYPE, STRUCT, OBJ, FLAG)   push_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.PP
expands to the correct format for the push function. The OBJ macro parameter should be a pointer to the object and not the object itself. 
.PP
Definition at line 78 of file function_macros.h.
.SS "#define push_back(TYPE, STRUCT, OBJ, FLAG)   push_back_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.PP
expands to the correct format for the push_back function The OBJ macro parameter should be a pointer to the object and not the object itself. 
.PP
Definition at line 85 of file function_macros.h.
.SS "#define push_front(TYPE, STRUCT, OBJ, FLAG)   push_front_##TYPE((STRUCT),(OBJ),sizeof *(OBJ),(FLAG))"
.PP
expands to the correct format for the push_front function The OBJ macro parameter should be a pointer to the object and not the object itself. 
.PP
Definition at line 92 of file function_macros.h.
.SS "#define resize(TYPE, STRUCT, SIZE)   resize_##TYPE((STRUCT),(SIZE))"
.PP
expands to the correct format for the resize function 
.PP
Definition at line 125 of file function_macros.h.
.SS "#define retrieve(TYPE, ITER)   retrieve_##TYPE((ITER))"
.PP
expands to the correct format for the retrieve iterator function 
.PP
Definition at line 226 of file function_macros.h.
.SS "#define rsort(TYPE, STRUCT)   rsort_##TYPE((STRUCT),O(STRUCT))"
.PP
expands to the correct format for the reverse sort function 
.PP
Definition at line 135 of file function_macros.h.
.SS "#define set_alloc(TYPE, STRUCT, OBJ)   set_alloc_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set alloc function 
.PP
Definition at line 200 of file function_macros.h.
.SS "#define set_compare(TYPE, STRUCT, OBJ)   set_compare_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set compare function 
.PP
Definition at line 180 of file function_macros.h.
.SS "#define set_copy(TYPE, STRUCT, OBJ)   set_copy_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set copy function 
.PP
Definition at line 195 of file function_macros.h.
.SS "#define set_dealloc(TYPE, STRUCT, OBJ)   set_dealloc_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set dealloc function 
.PP
Definition at line 205 of file function_macros.h.
.SS "#define set_free_objects(TYPE, STRUCT, OBJ)   set_free_objects_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set free objects function 
.PP
Definition at line 140 of file function_macros.h.
.SS "#define set_object_size(TYPE, STRUCT, OBJ)   set_object_size_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set object size function 
.PP
Definition at line 156 of file function_macros.h.
.SS "#define set_print(TYPE, STRUCT, OBJ)   set_print_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set print function 
.PP
Definition at line 190 of file function_macros.h.
.SS "#define set_rcompare(TYPE, STRUCT, OBJ)   set_rcompare_##TYPE((STRUCT),(OBJ))"
.PP
expands to the correct format for the set rcompare function 
.PP
Definition at line 185 of file function_macros.h.
.SS "#define size(TYPE, STRUCT)   size_##TYPE((STRUCT))"
.PP
expands to the correct format for the size function 
.PP
Definition at line 168 of file function_macros.h.
.SS "#define size_of(TYPE, STRUCT)   size_of_##TYPE((STRUCT))"
.PP
expands to the correct format for the size of function 
.PP
Definition at line 162 of file function_macros.h.
.SS "#define sort(TYPE, STRUCT)   sort_##TYPE((STRUCT),O(STRUCT))"
.PP
expands to the correct format for the sort function 
.PP
Definition at line 130 of file function_macros.h.
.SS "#define tail(TYPE, ITER)   tail_##TYPE((ITER))"
.PP
expands to the correct format for the tail iterator function 
.PP
Definition at line 216 of file function_macros.h.
.SS "#define top(TYPE, STRUCT)   top_##TYPE((STRUCT))"
.PP
expands to the correct format for the top function 
.PP
Definition at line 66 of file function_macros.h.
.SH "Author"
.PP 
Generated automatically by Doxygen for 'c generic library' from the source code.
