.TH "/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/priority_queue.h" 3 "Mon Aug 15 2011" ""c generic library"" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/priority_queue.h \- 
.PP
Generic Priority Queue implementation.  

.SH SYNOPSIS
.br
.PP
\fC#include 'gen/data_types.h'\fP
.br
\fC#include 'gen/gen_macros.h'\fP
.br
\fC#include 'gen/function_signatures.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_prio_queue_node\fP"
.br
.ti -1c
.RI "struct \fB_prio_queue\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_prio_queue_node\fP \fBPrioNode\fP"
.br
.ti -1c
.RI "typedef struct \fB_prio_queue\fP \fBPrioQueue\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int8_t \fBconstruct_PrioQueue\fP (\fBPrioQueue\fP *obj, size_t datasize, int flag)"
.br
.ti -1c
.RI "int8_t \fBconstruct_func_PrioQueue\fP (\fBPrioQueue\fP *obj, size_t datasize, int flag, void *(*alloc)(size_t), void(*dealloc)(void *), int32_t(*cmp)(const void *, const void *, size_t), void(*print)(const void *), void *(*copy)(void *, const void *, size_t))"
.br
.RI "\fIassigns all the * function pointers in one function call \fP"
.ti -1c
.RI "int8_t \fBdestruct_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIRemoves all the allocated memory for * the object. \fP"
.ti -1c
.RI "int8_t \fBclear_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIremoves all the data from the object \fP"
.ti -1c
.RI "\fBPrioQueue\fP * \fBduplicate_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIduplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. \fP"
.ti -1c
.RI "int8_t \fBprint_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIprints out the data inside the object \fP"
.ti -1c
.RI "int8_t \fBempty_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.ti -1c
.RI "size_t \fBsize_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBdump_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIdumps out the internal structure of the object \fP"
.ti -1c
.RI "size_t \fBsize_of_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBset_compare_PrioQueue\fP (\fBPrioQueue\fP *obj, int32_t(*cmp)(const void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBset_print_PrioQueue\fP (\fBPrioQueue\fP *obj, void(*print)(const void *))"
.br
.ti -1c
.RI "int8_t \fBset_alloc_PrioQueue\fP (\fBPrioQueue\fP *obj, void *(*alloc)(size_t))"
.br
.ti -1c
.RI "int8_t \fBset_dealloc_PrioQueue\fP (\fBPrioQueue\fP *obj, void(*dealloc)(void *))"
.br
.ti -1c
.RI "int8_t \fBset_copy_PrioQueue\fP (\fBPrioQueue\fP *obj, void *(*copy)(void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBinsert_PrioQueue\fP (\fBPrioQueue\fP *obj, int32_t priority, void *data, size_t datasize)"
.br
.ti -1c
.RI "void * \fBtop_data_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIretrieves the data of the top item in the queue \fP"
.ti -1c
.RI "int32_t \fBtop_prio_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIretrieves the priority of the top item in the queue \fP"
.ti -1c
.RI "int8_t \fBpop_PrioQueue\fP (\fBPrioQueue\fP *obj)"
.br
.RI "\fIpops the item that is at the top of the queue \fP"
.ti -1c
.RI "int8_t \fBinc_prio_PrioQueue\fP (\fBPrioQueue\fP *obj, int32_t amt, void *data, size_t datasize)"
.br
.RI "\fIincrement the priority of the given data \fP"
.ti -1c
.RI "int8_t \fBdec_prio_PrioQueue\fP (\fBPrioQueue\fP *obj, int32_t amt, void *data, size_t datasize)"
.br
.RI "\fIdecrement the priority of the given data \fP"
.ti -1c
.RI "int32_t \fBfind_prio_PrioQueue\fP (\fBPrioQueue\fP *obj, void *data, size_t datasize)"
.br
.ti -1c
.RI "int8_t \fBresize_PrioQueue\fP (\fBPrioQueue\fP *obj, size_t size)"
.br
.RI "\fIResizes the Priority Queue. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Generic Priority Queue implementation. 

Copyright 2006, All Rights Reserved, Micah Villmow
.PP
The generic priority queue implementations, when completed will be able to be based on any heap type. 
.PP
Definition in file \fBpriority_queue.h\fP.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_prio_queue_node\fP  \fBPrioNode\fP"
.SS "typedef struct \fB_prio_queue\fP  \fBPrioQueue\fP"
.SH "Function Documentation"
.PP 
.SS "int8_t clear_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
removes all the data from the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to clear * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * 
.RE
.PP

.SS "int8_t construct_func_PrioQueue (\fBPrioQueue\fP *obj, size_tdatasize, intflag, void *(*)(size_t)alloc, void(*)(void *)dealloc, int32_t(*)(const void *, const void *, size_t)cmp, void(*)(const void *)print, void *(*)(void *, const void *, size_t)copy)"
.PP
assigns all the * function pointers in one function call * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.br
\fIalloc\fP the allocation functor * 
.br
\fIdealloc\fP the deallocation functor * 
.br
\fIcmp\fP the comparison functor * 
.br
\fIprint\fP the print functor * 
.br
\fIcopy\fP the copy functor * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP

.SS "int8_t construct_PrioQueue (\fBPrioQueue\fP *obj, size_tdatasize, intflag)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP
\fBWarning:\fP
.RS 4
if you are using a local variable * clear out the memory before calling this * function using memset or bzero 
.RE
.PP

.SS "int8_t dec_prio_PrioQueue (\fBPrioQueue\fP *obj, int32_tamt, void *data, size_tdatasize)"
.PP
decrement the priority of the given data \fBParameters:\fP
.RS 4
\fIobj\fP the object that contains the data 
.br
\fIamt\fP the amount to decrement the priority by 
.br
\fIdata\fP the data to decrease priority of 
.br
\fIdatasize\fP the size of the data 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t destruct_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
Removes all the allocated memory for * the object. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to deinitialize * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on succss, non-zero on failure * 
.RE
.PP

.SS "int8_t dump_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
dumps out the internal structure of the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to dump the internal structure of * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success,non-zero on error * 
.RE
.PP

.SS "\fBPrioQueue\fP* duplicate_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
duplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to duplicate * 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of the object or NULL on error * 
.RE
.PP

.SS "int8_t empty_PrioQueue (\fBPrioQueue\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to check for emptiness * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on empty, non-zero otherwise 
.RE
.PP

.SS "int32_t find_prio_PrioQueue (\fBPrioQueue\fP *obj, void *data, size_tdatasize)"
.SS "int8_t inc_prio_PrioQueue (\fBPrioQueue\fP *obj, int32_tamt, void *data, size_tdatasize)"
.PP
increment the priority of the given data \fBParameters:\fP
.RS 4
\fIobj\fP the object that contains the data 
.br
\fIamt\fP the amount to increment the priority by 
.br
\fIdata\fP the data to increase the priority of 
.br
\fIdatasize\fP the size of the data 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t insert_PrioQueue (\fBPrioQueue\fP *obj, int32_tpriority, void *data, size_tdatasize)"\fBParameters:\fP
.RS 4
\fIobj\fP the object to insert the items in 
.br
\fIpriority\fP the priority of the data 
.br
\fIdata\fP the data to be inserted 
.br
\fIdatasize\fP the size of the data 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t pop_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
pops the item that is at the top of the queue \fBParameters:\fP
.RS 4
\fIobj\fP the object to pop the top item off of 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t print_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
prints out the data inside the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to print * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t resize_PrioQueue (\fBPrioQueue\fP *obj, size_tsize)"
.PP
Resizes the Priority Queue. \fBParameters:\fP
.RS 4
\fIobj\fP the object to resize 
.br
\fIize\fP the size to resize the object to 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_alloc_PrioQueue (\fBPrioQueue\fP *obj, void *(*)(size_t)alloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the alloc funtion for * 
.br
\fIalloc\fP the function pointer to the alloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_compare_PrioQueue (\fBPrioQueue\fP *obj, int32_t(*)(const void *, const void *, size_t)cmp)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the compare function of * 
.br
\fIcmp\fP the function pointer to the comparison function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_copy_PrioQueue (\fBPrioQueue\fP *obj, void *(*)(void *, const void *, size_t)copy)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to set the copy function for * 
.br
\fIcopy\fP the function pointer to the copy function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_dealloc_PrioQueue (\fBPrioQueue\fP *obj, void(*)(void *)dealloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP the obj to set the dealloc function for * 
.br
\fIdealloc\fP the function pointer to the dealloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_print_PrioQueue (\fBPrioQueue\fP *obj, void(*)(const void *)print)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the print function of * 
.br
\fIprint\fP the function pointer to the print function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "size_t size_of_PrioQueue (\fBPrioQueue\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of the object or 0 on error/empty 
.RE
.PP

.SS "size_t size_PrioQueue (\fBPrioQueue\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of object or zero on failure 
.RE
.PP

.SS "void* top_data_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
retrieves the data of the top item in the queue \fBParameters:\fP
.RS 4
\fIobj\fP the object to retrieve the data of 
.RE
.PP
\fBReturns:\fP
.RS 4
data of the top item or NULL on error 
.RE
.PP

.SS "int32_t top_prio_PrioQueue (\fBPrioQueue\fP *obj)"
.PP
retrieves the priority of the top item in the queue \fBParameters:\fP
.RS 4
\fIobj\fP the object to retrieve the top priority of 
.RE
.PP
\fBReturns:\fP
.RS 4
priority of top object or INT_MIN on error 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 'c generic library' from the source code.
