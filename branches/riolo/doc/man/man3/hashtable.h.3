.TH "/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/hashtable.h" 3 "Mon Aug 15 2011" ""c generic library"" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/Users/matthieuriolo/Sourcecode/libcgeneric/branches/riolo/libcgeneric/hashtable.h \- 
.PP
Various implementations of hash tables.  

.SH SYNOPSIS
.br
.PP
\fC#include 'gen/data_types.h'\fP
.br
\fC#include 'gen/gen_macros.h'\fP
.br
\fC#include 'gen/function_signatures.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_open_hash_table\fP"
.br
.ti -1c
.RI "struct \fB_open_hash_iterator\fP"
.br
.ti -1c
.RI "struct \fB_closed_hash_table\fP"
.br
.ti -1c
.RI "struct \fB_closed_hash_iterator\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_Hash_List_Node\fP \fBHashListNode\fP"
.br
.ti -1c
.RI "typedef struct \fB_open_hash_table\fP \fBOHTable\fP"
.br
.ti -1c
.RI "typedef struct \fB_open_hash_iterator\fP \fBOHTableIter\fP"
.br
.ti -1c
.RI "typedef struct \fB_Hash_Node\fP \fBHashNode\fP"
.br
.ti -1c
.RI "typedef struct \fB_closed_hash_table\fP \fBCHTable\fP"
.br
.ti -1c
.RI "typedef struct \fB_closed_hash_iterator\fP \fBCHTableIter\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int8_t \fBconstruct_OHTable\fP (\fBOHTable\fP *obj, size_t datasize, int flag)"
.br
.ti -1c
.RI "int8_t \fBconstruct_func_OHTable\fP (\fBOHTable\fP *obj, size_t datasize, int flag, void *(*alloc)(size_t), void(*dealloc)(void *), int32_t(*cmp)(const void *, const void *, size_t), void(*print)(const void *), void *(*copy)(void *, const void *, size_t))"
.br
.RI "\fIassigns all the * function pointers in one function call \fP"
.ti -1c
.RI "int8_t \fBdestruct_OHTable\fP (\fBOHTable\fP *obj)"
.br
.RI "\fIRemoves all the allocated memory for * the object. \fP"
.ti -1c
.RI "int8_t \fBclear_OHTable\fP (\fBOHTable\fP *obj)"
.br
.RI "\fIremoves all the data from the object \fP"
.ti -1c
.RI "\fBOHTable\fP * \fBduplicate_OHTable\fP (\fBOHTable\fP *obj)"
.br
.RI "\fIduplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. \fP"
.ti -1c
.RI "int8_t \fBprint_OHTable\fP (\fBOHTable\fP *obj)"
.br
.RI "\fIprints out the data inside the object \fP"
.ti -1c
.RI "int8_t \fBempty_OHTable\fP (\fBOHTable\fP *obj)"
.br
.ti -1c
.RI "size_t \fBsize_OHTable\fP (\fBOHTable\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBdump_OHTable\fP (\fBOHTable\fP *obj)"
.br
.RI "\fIdumps out the internal structure of the object \fP"
.ti -1c
.RI "size_t \fBsize_of_OHTable\fP (\fBOHTable\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBset_compare_OHTable\fP (\fBOHTable\fP *obj, int32_t(*cmp)(const void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBset_print_OHTable\fP (\fBOHTable\fP *obj, void(*print)(const void *))"
.br
.ti -1c
.RI "int8_t \fBset_alloc_OHTable\fP (\fBOHTable\fP *obj, void *(*alloc)(size_t))"
.br
.ti -1c
.RI "int8_t \fBset_dealloc_OHTable\fP (\fBOHTable\fP *obj, void(*dealloc)(void *))"
.br
.ti -1c
.RI "int8_t \fBset_copy_OHTable\fP (\fBOHTable\fP *obj, void *(*copy)(void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBinsert_OHTable\fP (\fBOHTable\fP *table, void *element, size_t elesize, int8_t flag)"
.br
.ti -1c
.RI "int8_t \fBdelete_OHTable\fP (\fBOHTable\fP *table, void *element, size_t elesize)"
.br
.ti -1c
.RI "void * \fBfind_OHTable\fP (\fBOHTable\fP *table, void *element, size_t elesize)"
.br
.ti -1c
.RI "int8_t \fBset_hash_OHTable\fP (\fBOHTable\fP *table, uint32_t(*hash)(void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBprev_OHTableIter\fP (\fBOHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the prev element in the * obj \fP"
.ti -1c
.RI "int8_t \fBnext_OHTableIter\fP (\fBOHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the next element in the * obj \fP"
.ti -1c
.RI "int8_t \fBassign_OHTableIter\fP (\fBOHTableIter\fP *iter, \fBOHTable\fP *obj)"
.br
.RI "\fIassign statically created iterator to the obj \fP"
.ti -1c
.RI "void \fBdestroy_OHTableIter\fP (\fBOHTableIter\fP *iter)"
.br
.ti -1c
.RI "int8_t \fBhead_OHTableIter\fP (\fBOHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the head of the obj * it has been assigned to \fP"
.ti -1c
.RI "int8_t \fBtail_OHTableIter\fP (\fBOHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the tail of the * obj it has been assigned to \fP"
.ti -1c
.RI "\fBOHTableIter\fP * \fBcreate_OHTableIter\fP (\fBOHTable\fP *obj)"
.br
.RI "\fIcreates and iterator and assigns it to the obj \fP"
.ti -1c
.RI "void * \fBretrieve_OHTableIter\fP (\fBOHTableIter\fP *iter)"
.br
.RI "\fIreturns a void poitner to the object that * the iterator points to \fP"
.ti -1c
.RI "int8_t \fBcopy_OHTableIter\fP (\fBOHTableIter\fP *src, \fBOHTableIter\fP *dst)"
.br
.ti -1c
.RI "int8_t \fBswap_OHTableIter\fP (\fBOHTableIter\fP *iter1, \fBOHTableIter\fP *iter2)"
.br
.RI "\fIswaps the position of iter1 and iter2 * \fP"
.ti -1c
.RI "int8_t \fBconstruct_CHTable\fP (\fBCHTable\fP *obj, size_t datasize, int flag)"
.br
.ti -1c
.RI "int8_t \fBconstruct_func_CHTable\fP (\fBCHTable\fP *obj, size_t datasize, int flag, void *(*alloc)(size_t), void(*dealloc)(void *), int32_t(*cmp)(const void *, const void *, size_t), void(*print)(const void *), void *(*copy)(void *, const void *, size_t))"
.br
.RI "\fIassigns all the * function pointers in one function call \fP"
.ti -1c
.RI "int8_t \fBdestruct_CHTable\fP (\fBCHTable\fP *obj)"
.br
.RI "\fIRemoves all the allocated memory for * the object. \fP"
.ti -1c
.RI "int8_t \fBclear_CHTable\fP (\fBCHTable\fP *obj)"
.br
.RI "\fIremoves all the data from the object \fP"
.ti -1c
.RI "\fBCHTable\fP * \fBduplicate_CHTable\fP (\fBCHTable\fP *obj)"
.br
.RI "\fIduplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. \fP"
.ti -1c
.RI "int8_t \fBprint_CHTable\fP (\fBCHTable\fP *obj)"
.br
.RI "\fIprints out the data inside the object \fP"
.ti -1c
.RI "int8_t \fBempty_CHTable\fP (\fBCHTable\fP *obj)"
.br
.ti -1c
.RI "size_t \fBsize_CHTable\fP (\fBCHTable\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBdump_CHTable\fP (\fBCHTable\fP *obj)"
.br
.RI "\fIdumps out the internal structure of the object \fP"
.ti -1c
.RI "size_t \fBsize_of_CHTable\fP (\fBCHTable\fP *obj)"
.br
.ti -1c
.RI "int8_t \fBset_compare_CHTable\fP (\fBCHTable\fP *obj, int32_t(*cmp)(const void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBset_print_CHTable\fP (\fBCHTable\fP *obj, void(*print)(const void *))"
.br
.ti -1c
.RI "int8_t \fBset_alloc_CHTable\fP (\fBCHTable\fP *obj, void *(*alloc)(size_t))"
.br
.ti -1c
.RI "int8_t \fBset_dealloc_CHTable\fP (\fBCHTable\fP *obj, void(*dealloc)(void *))"
.br
.ti -1c
.RI "int8_t \fBset_copy_CHTable\fP (\fBCHTable\fP *obj, void *(*copy)(void *, const void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBinsert_CHTable\fP (\fBCHTable\fP *table, void *element, size_t elesize, int8_t flag)"
.br
.ti -1c
.RI "int8_t \fBdelete_CHTable\fP (\fBCHTable\fP *table, void *element, size_t elesize)"
.br
.ti -1c
.RI "void * \fBfind_CHTable\fP (\fBCHTable\fP *table, void *element, size_t elesize)"
.br
.ti -1c
.RI "int8_t \fBset_hash_CHTable\fP (\fBCHTable\fP *table, uint32_t(*hash)(void *, size_t))"
.br
.ti -1c
.RI "int8_t \fBset_probe_CHTable\fP (\fBCHTable\fP *table, uint32_t(*prob)(uint32_t))"
.br
.ti -1c
.RI "int8_t \fBprev_CHTableIter\fP (\fBCHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the prev element in the * obj \fP"
.ti -1c
.RI "int8_t \fBnext_CHTableIter\fP (\fBCHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the next element in the * obj \fP"
.ti -1c
.RI "int8_t \fBassign_CHTableIter\fP (\fBCHTableIter\fP *iter, \fBCHTable\fP *obj)"
.br
.RI "\fIassign statically created iterator to the obj \fP"
.ti -1c
.RI "void \fBdestroy_CHTableIter\fP (\fBCHTableIter\fP *iter)"
.br
.ti -1c
.RI "int8_t \fBhead_CHTableIter\fP (\fBCHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the head of the obj * it has been assigned to \fP"
.ti -1c
.RI "int8_t \fBtail_CHTableIter\fP (\fBCHTableIter\fP *iter)"
.br
.RI "\fImoves the iterator to the tail of the * obj it has been assigned to \fP"
.ti -1c
.RI "\fBCHTableIter\fP * \fBcreate_CHTableIter\fP (\fBCHTable\fP *obj)"
.br
.RI "\fIcreates and iterator and assigns it to the obj \fP"
.ti -1c
.RI "void * \fBretrieve_CHTableIter\fP (\fBCHTableIter\fP *iter)"
.br
.RI "\fIreturns a void poitner to the object that * the iterator points to \fP"
.ti -1c
.RI "int8_t \fBcopy_CHTableIter\fP (\fBCHTableIter\fP *src, \fBCHTableIter\fP *dst)"
.br
.ti -1c
.RI "int8_t \fBswap_CHTableIter\fP (\fBCHTableIter\fP *iter1, \fBCHTableIter\fP *iter2)"
.br
.RI "\fIswaps the position of iter1 and iter2 * \fP"
.ti -1c
.RI "uint32_t \fBchar_hash\fP (void *key, size_t len)"
.br
.ti -1c
.RI "uint32_t \fBnum_hash\fP (void *key, size_t len)"
.br
.ti -1c
.RI "uint32_t \fBlinear_probing\fP (uint32_t num)"
.br
.ti -1c
.RI "uint32_t \fBquadratic_probing\fP (uint32_t num)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Various implementations of hash tables. 

Copyright 2006, All Rights Reserved, Micah Villmow 
.PP
Definition in file \fBhashtable.h\fP.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_closed_hash_table\fP \fBCHTable\fP"
.PP
Definition at line 60 of file hashtable.h.
.SS "typedef struct \fB_closed_hash_iterator\fP  \fBCHTableIter\fP"
.SS "typedef struct \fB_Hash_List_Node\fP \fBHashListNode\fP"
.PP
Definition at line 13 of file hashtable.h.
.SS "typedef struct \fB_Hash_Node\fP \fBHashNode\fP"
.PP
Definition at line 59 of file hashtable.h.
.SS "typedef struct \fB_open_hash_table\fP  \fBOHTable\fP"
.SS "typedef struct \fB_open_hash_iterator\fP  \fBOHTableIter\fP"
.SH "Function Documentation"
.PP 
.SS "int8_t assign_CHTableIter (\fBCHTableIter\fP *iter, \fBCHTable\fP *obj)"
.PP
assign statically created iterator to the obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to assign to the obj * 
.br
\fIobj\fP the obj to point the iterator to * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t assign_OHTableIter (\fBOHTableIter\fP *iter, \fBOHTable\fP *obj)"
.PP
assign statically created iterator to the obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to assign to the obj * 
.br
\fIobj\fP the obj to point the iterator to * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "uint32_t char_hash (void *key, size_tlen)"
.SS "int8_t clear_CHTable (\fBCHTable\fP *obj)"
.PP
removes all the data from the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to clear * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * 
.RE
.PP

.SS "int8_t clear_OHTable (\fBOHTable\fP *obj)"
.PP
removes all the data from the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to clear * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * 
.RE
.PP

.SS "int8_t construct_CHTable (\fBCHTable\fP *obj, size_tdatasize, intflag)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP
\fBWarning:\fP
.RS 4
if you are using a local variable * clear out the memory before calling this * function using memset or bzero 
.RE
.PP

.SS "int8_t construct_func_CHTable (\fBCHTable\fP *obj, size_tdatasize, intflag, void *(*)(size_t)alloc, void(*)(void *)dealloc, int32_t(*)(const void *, const void *, size_t)cmp, void(*)(const void *)print, void *(*)(void *, const void *, size_t)copy)"
.PP
assigns all the * function pointers in one function call * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.br
\fIalloc\fP the allocation functor * 
.br
\fIdealloc\fP the deallocation functor * 
.br
\fIcmp\fP the comparison functor * 
.br
\fIprint\fP the print functor * 
.br
\fIcopy\fP the copy functor * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP

.SS "int8_t construct_func_OHTable (\fBOHTable\fP *obj, size_tdatasize, intflag, void *(*)(size_t)alloc, void(*)(void *)dealloc, int32_t(*)(const void *, const void *, size_t)cmp, void(*)(const void *)print, void *(*)(void *, const void *, size_t)copy)"
.PP
assigns all the * function pointers in one function call * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.br
\fIalloc\fP the allocation functor * 
.br
\fIdealloc\fP the deallocation functor * 
.br
\fIcmp\fP the comparison functor * 
.br
\fIprint\fP the print functor * 
.br
\fIcopy\fP the copy functor * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP

.SS "int8_t construct_OHTable (\fBOHTable\fP *obj, size_tdatasize, intflag)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to initialize * 
.br
\fIdatasize\fP the size of the data to store * 
.br
\fIflag\fP the flag for how to handle memory * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on failure * * 
.RE
.PP
\fBWarning:\fP
.RS 4
if you are using a local variable * clear out the memory before calling this * function using memset or bzero 
.RE
.PP

.SS "int8_t copy_CHTableIter (\fBCHTableIter\fP *src, \fBCHTableIter\fP *dst)"* 
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP the source iterator * 
.br
\fIdst\fP the destination iterator * 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success, non-zero on error 
.RE
.PP

.SS "int8_t copy_OHTableIter (\fBOHTableIter\fP *src, \fBOHTableIter\fP *dst)"* 
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP the source iterator * 
.br
\fIdst\fP the destination iterator * 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success, non-zero on error 
.RE
.PP

.SS "\fBCHTableIter\fP* create_CHTableIter (\fBCHTable\fP *obj)"
.PP
creates and iterator and assigns it to the obj * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to create iterator for * 
.RE
.PP
\fBReturns:\fP
.RS 4
returns an iterator to the obj on success * or NULL on error * 
.RE
.PP

.SS "\fBOHTableIter\fP* create_OHTableIter (\fBOHTable\fP *obj)"
.PP
creates and iterator and assigns it to the obj * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to create iterator for * 
.RE
.PP
\fBReturns:\fP
.RS 4
returns an iterator to the obj on success * or NULL on error * 
.RE
.PP

.SS "int8_t delete_CHTable (\fBCHTable\fP *table, void *element, size_telesize)"
.SS "int8_t delete_OHTable (\fBOHTable\fP *table, void *element, size_telesize)"
.SS "void destroy_CHTableIter (\fBCHTableIter\fP *iter)"* 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to destroy * 
.RE
.PP
\fBWarning:\fP
.RS 4
only use this in conjunction with create 
.RE
.PP

.SS "void destroy_OHTableIter (\fBOHTableIter\fP *iter)"* 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to destroy * 
.RE
.PP
\fBWarning:\fP
.RS 4
only use this in conjunction with create 
.RE
.PP

.SS "int8_t destruct_CHTable (\fBCHTable\fP *obj)"
.PP
Removes all the allocated memory for * the object. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to deinitialize * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on succss, non-zero on failure * 
.RE
.PP

.SS "int8_t destruct_OHTable (\fBOHTable\fP *obj)"
.PP
Removes all the allocated memory for * the object. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to deinitialize * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on succss, non-zero on failure * 
.RE
.PP

.SS "int8_t dump_CHTable (\fBCHTable\fP *obj)"
.PP
dumps out the internal structure of the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to dump the internal structure of * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success,non-zero on error * 
.RE
.PP

.SS "int8_t dump_OHTable (\fBOHTable\fP *obj)"
.PP
dumps out the internal structure of the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to dump the internal structure of * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success,non-zero on error * 
.RE
.PP

.SS "\fBCHTable\fP* duplicate_CHTable (\fBCHTable\fP *obj)"
.PP
duplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to duplicate * 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of the object or NULL on error * 
.RE
.PP

.SS "\fBOHTable\fP* duplicate_OHTable (\fBOHTable\fP *obj)"
.PP
duplicates the object * * Duplicates all the data that the object holds * and returns it in its own object. The new object * has copies of the data and does not use copy * on write semantics. Therefor the new object will * handle the deallocation of data memory * when destroyed. * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to duplicate * 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of the object or NULL on error * 
.RE
.PP

.SS "int8_t empty_CHTable (\fBCHTable\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to check for emptiness * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on empty, non-zero otherwise 
.RE
.PP

.SS "int8_t empty_OHTable (\fBOHTable\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to check for emptiness * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on empty, non-zero otherwise 
.RE
.PP

.SS "void* find_CHTable (\fBCHTable\fP *table, void *element, size_telesize)"
.SS "void* find_OHTable (\fBOHTable\fP *table, void *element, size_telesize)"
.SS "int8_t head_CHTableIter (\fBCHTableIter\fP *iter)"
.PP
moves the iterator to the head of the obj * it has been assigned to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to move to the head * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t head_OHTableIter (\fBOHTableIter\fP *iter)"
.PP
moves the iterator to the head of the obj * it has been assigned to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to move to the head * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t insert_CHTable (\fBCHTable\fP *table, void *element, size_telesize, int8_tflag)"
.SS "int8_t insert_OHTable (\fBOHTable\fP *table, void *element, size_telesize, int8_tflag)"
.SS "uint32_t linear_probing (uint32_tnum)"
.SS "int8_t next_CHTableIter (\fBCHTableIter\fP *iter)"
.PP
moves the iterator to the next element in the * obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iter to move to the next element * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t next_OHTableIter (\fBOHTableIter\fP *iter)"
.PP
moves the iterator to the next element in the * obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iter to move to the next element * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "uint32_t num_hash (void *key, size_tlen)"
.SS "int8_t prev_CHTableIter (\fBCHTableIter\fP *iter)"
.PP
moves the iterator to the prev element in the * obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iter to move to the prev element * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t prev_OHTableIter (\fBOHTableIter\fP *iter)"
.PP
moves the iterator to the prev element in the * obj * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iter to move to the prev element * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t print_CHTable (\fBCHTable\fP *obj)"
.PP
prints out the data inside the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to print * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t print_OHTable (\fBOHTable\fP *obj)"
.PP
prints out the data inside the object * 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to print * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "uint32_t quadratic_probing (uint32_tnum)"
.SS "void* retrieve_CHTableIter (\fBCHTableIter\fP *iter)"
.PP
returns a void poitner to the object that * the iterator points to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to retrieve the object from * 
.RE
.PP
\fBReturns:\fP
.RS 4
object on success, NULL on error * 
.RE
.PP

.SS "void* retrieve_OHTableIter (\fBOHTableIter\fP *iter)"
.PP
returns a void poitner to the object that * the iterator points to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to retrieve the object from * 
.RE
.PP
\fBReturns:\fP
.RS 4
object on success, NULL on error * 
.RE
.PP

.SS "int8_t set_alloc_CHTable (\fBCHTable\fP *obj, void *(*)(size_t)alloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the alloc funtion for * 
.br
\fIalloc\fP the function pointer to the alloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_alloc_OHTable (\fBOHTable\fP *obj, void *(*)(size_t)alloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the alloc funtion for * 
.br
\fIalloc\fP the function pointer to the alloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_compare_CHTable (\fBCHTable\fP *obj, int32_t(*)(const void *, const void *, size_t)cmp)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the compare function of * 
.br
\fIcmp\fP the function pointer to the comparison function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_compare_OHTable (\fBOHTable\fP *obj, int32_t(*)(const void *, const void *, size_t)cmp)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the compare function of * 
.br
\fIcmp\fP the function pointer to the comparison function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_copy_CHTable (\fBCHTable\fP *obj, void *(*)(void *, const void *, size_t)copy)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to set the copy function for * 
.br
\fIcopy\fP the function pointer to the copy function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_copy_OHTable (\fBOHTable\fP *obj, void *(*)(void *, const void *, size_t)copy)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to set the copy function for * 
.br
\fIcopy\fP the function pointer to the copy function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_dealloc_CHTable (\fBCHTable\fP *obj, void(*)(void *)dealloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP the obj to set the dealloc function for * 
.br
\fIdealloc\fP the function pointer to the dealloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_dealloc_OHTable (\fBOHTable\fP *obj, void(*)(void *)dealloc)"* 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP the obj to set the dealloc function for * 
.br
\fIdealloc\fP the function pointer to the dealloc function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_hash_CHTable (\fBCHTable\fP *table, uint32_t(*)(void *, size_t)hash)"
.SS "int8_t set_hash_OHTable (\fBOHTable\fP *table, uint32_t(*)(void *, size_t)hash)"
.SS "int8_t set_print_CHTable (\fBCHTable\fP *obj, void(*)(const void *)print)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the print function of * 
.br
\fIprint\fP the function pointer to the print function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_print_OHTable (\fBOHTable\fP *obj, void(*)(const void *)print)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to set the print function of * 
.br
\fIprint\fP the function pointer to the print function * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t set_probe_CHTable (\fBCHTable\fP *table, uint32_t(*)(uint32_t)prob)"
.SS "size_t size_CHTable (\fBCHTable\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of object or zero on failure 
.RE
.PP

.SS "size_t size_of_CHTable (\fBCHTable\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of the object or 0 on error/empty 
.RE
.PP

.SS "size_t size_of_OHTable (\fBOHTable\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the obj to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of the object or 0 on error/empty 
.RE
.PP

.SS "size_t size_OHTable (\fBOHTable\fP *obj)"* 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to get the size of * 
.RE
.PP
\fBReturns:\fP
.RS 4
size of object or zero on failure 
.RE
.PP

.SS "int8_t swap_CHTableIter (\fBCHTableIter\fP *iter1, \fBCHTableIter\fP *iter2)"
.PP
swaps the position of iter1 and iter2 * * 
.PP
\fBParameters:\fP
.RS 4
\fIiter1\fP the first iterator * 
.br
\fIiter2\fP the second iterator * 
.RE
.PP
\fBWarning:\fP
.RS 4
iterators must be pointing to same parent * object or the swap will fail * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t swap_OHTableIter (\fBOHTableIter\fP *iter1, \fBOHTableIter\fP *iter2)"
.PP
swaps the position of iter1 and iter2 * * 
.PP
\fBParameters:\fP
.RS 4
\fIiter1\fP the first iterator * 
.br
\fIiter2\fP the second iterator * 
.RE
.PP
\fBWarning:\fP
.RS 4
iterators must be pointing to same parent * object or the swap will fail * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error 
.RE
.PP

.SS "int8_t tail_CHTableIter (\fBCHTableIter\fP *iter)"
.PP
moves the iterator to the tail of the * obj it has been assigned to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to move to the tail * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SS "int8_t tail_OHTableIter (\fBOHTableIter\fP *iter)"
.PP
moves the iterator to the tail of the * obj it has been assigned to * 
.PP
\fBParameters:\fP
.RS 4
\fIiter\fP the iterator to move to the tail * 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, non-zero on error * 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 'c generic library' from the source code.
